import mime from 'mime';
export function acceptParams(str, index) {
    const parts = str.split(/ *; */);
    const ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
    for (const part of parts) {
        const pms = part.split(/ *= */);
        if ('q' === pms[0])
            ret.quality = Number.parseFloat(pms[1]);
        else
            ret.params[pms[0]] = pms[1];
    }
    return ret;
}
export const normalizeType = (type) => ~type.indexOf('/') ? acceptParams(type) : { value: mime.getType(type), params: {} };
export function normalizeTypes(types) {
    const ret = [];
    for (const type of types) {
        ret.push(normalizeType(type));
    }
    return ret;
}
const matchHtmlRegExp = /["'&<>]/;
export function escapeHTML(str) {
    const match = matchHtmlRegExp.exec(str);
    if (!match) {
        // stringify in case input is not a string
        return String(str);
    }
    let escapeChar;
    let html = '';
    let index = 0;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escapeChar = '&quot;';
                break;
            case 38: // &
                escapeChar = '&amp;';
                break;
            case 39: // '
                escapeChar = '&#39;';
                break;
            case 60: // <
                escapeChar = '&lt;';
                break;
            case 62: // >
                escapeChar = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index)
            html += str.substring(lastIndex, index);
        lastIndex = index + 1;
        html += escapeChar;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
//# sourceMappingURL=util.js.map